{"version":3,"sources":["../../node_modules/codemirror/keymap/vim.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","replace","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","enterVimMode","cm","setOption","signal","mode","on","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","off","state","vim","detachVimMap","next","this","keyMap","rmClass","getWrapperElement","attach","attachVimMap","prev","addClass","defineOption","val","getOption","Init","test","cmKey","key","undefined","vimKey","cmKeyToVimKey","cmd","findKey","modifiers","Shift","Ctrl","Alt","Cmd","Mod","specialKeys","Enter","Backspace","Delete","Insert","charAt","pieces","split","lastPiece","length","hasCharacter","i","piece","isUpperCase","toLowerCase","join","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","ch","bigWordCharTest","makeKeyRange","start","size","push","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","line","firstLine","lastLine","isLowerCase","k","isMatchableSymbol","indexOf","isNumber","isWhiteSpaceString","inArray","arr","options","defaultValue","aliases","callback","Error","value","cfg","option","scope","local","createCircularJumpList","pointer","head","tail","buffer","Array","add","oldCur","newCur","current","curMark","useNextSlot","cursor","trashMark","clear","setBookmark","markPos","find","cursorEqual","move","offset","mark","inc","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","prototype","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","bottom","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","marks","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","increment","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","match","exec","substring","index","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","slice","thisMatch","window","clearTimeout","setTimeout","selections","listSelections","here","replaceRange","pop","handleKeyNonInsertMode","keysMatcher","pushRepeatDigit","operation","curOp","isVimOp","processCommand","e","console","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","_mapCommand","defineRegister","prefixRepeat","motionRepeat","n","getRepeat","repeat","parseInt","reason","Register","text","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","toString","registers","unnamedRegister","isValidRegister","shiftNumericRegisters_","append","historyBuffer","iterator","initialPrefix","nextMatch","up","dir","element","j","pushInput","splice","reset","matches","commandMatches","full","partial","bestMatch","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","ignoreCase","smartCase","updateSearchQuery","showConfirm","onPromptClose","scrollTo","left","top","logSearchQuery","onPromptKeyUp","close","keyName","target","selectionEnd","selectionStart","Math","min","parsedQuery","scrollIntoView","findNext","clearSearchHighlight","onPromptKeyDown","e_stop","focus","shift","showPrompt","onClose","desc","searchPromptDesc","onKeyUp","onKeyDown","word","expandWordUnderCursor","isKeyword","getLine","end","escapeRegex","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","anchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateCmSelection","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","ranges","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","setSelections","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","range","floor","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","moveToStartOfLine","charCoords","res","findPosV","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","retval","clipPos","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","style","getTokenTypeAt","matched","findMatchingBracket","to","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","mirroredPairs","(",")","{","}","[","]","selfPaired","'","\"","character","selectCompanionObject","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fn","fillArray","times","change","args","finalHead","inVisualBlock","getRange","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","commands","newlineAndIndent","getSelection","replacement","replaceSelections","delete","indent","startLine","endLine","indentLine","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","re","numberStr","token","number","from","repeatLastEdit","includeLineBreak","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","getOffset","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","isClipped","curHead","primIndex","getIndex","wasClipped","base","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","width","setSelection","updateFakeCursor","headOffset","anchorOffset","right","getHead","moveHead","selection","lines","firstNonWS","search","_forward","noSymbol","wordStart","symbolToMode","*","/","m","M","#","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","found","method","preprocess","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","charIdxInLine","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","bracketRegexp","openSym","curChar","scanForBracket","bracketRegex","chars","len","firstIndex","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","dialog","template","shortText","selectValueOnOpen","prompt","splitBySlash","argString","slashes","findUnescapedSlashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","\\n","\\r","\\t","translateRegexReplace","unescapes","\\/","\\\\","unescapeRegexReplace","stream","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","RegExp","regexPart","forceIgnoreCase","flagsPart","regexp","openNotification","duration","alert","makePrompt","raw","regexEqual","r1","r2","props","rawQuery","source","matchSol","sol","skipToEnd","backUp","searchState","removeOverlay","addOverlay","showMatchesOnScrollbar","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","history","doc","done","event","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","result","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","delim","argDelimiter","user","mapping","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","setlocal","setglobal","regArgs","regInfo","sort","reverse","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","substr","err","lineStart","radix","numPart","textPart","matchPart","compareFn","a","b","anum","bnum","comparePatternFn","textOld","global","matchedLines","content","nextCommand","substitute","replacePart","trailing","count","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","replaceAll","newText","_value","savedCallback","detach","insertModeChangeRegister","lastChange","selLength","logInsertModeChange","extra","fallthrough","imc","repeatInsertModeChanges","changeObj","maybeReset","handleExternalSelection","markText","className","somethingSelected","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding"],"mappings":"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","file":"vim.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm, false);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        throw Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          throw Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        throw Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController({}),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController({})\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; };\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers[name];\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(0) == '\\n') {\n          text = text.slice(1) + '\\n';\n        }\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          inputState.selectedCharacter = lastChar(keys);\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        vim.lastHPos = Infinity;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        do {\n          symbol = lineText.charAt(ch++);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        } while (symbol);\n        if (symbol) {\n          var matched = cm.findMatchingBracket(Pos(line, ch));\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '['};\n        var selfPaired = {'\\'': true, '\"': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n');\n            for (var i = 0; i < text.length; i++) {\n              text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /-?\\d+/g;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        var token;\n        while ((match = re.exec(lineStr)) !== null) {\n          token = match[0];\n          start = match.index;\n          end = start + token.length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (token) {\n          var increment = actionArgs.increase ? 1 : -1;\n          var number = parseInt(token) + (increment * actionArgs.repeat);\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          numberStr = number.toString();\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function getOffset(anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      };\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[\\w\\-]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      primIndex = head.line == lastLine ? selections.length - 1 : 0;\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /**\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, null, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, null, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      var slashes = findUnescapedSlashes(argString) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSlashes(str) {\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == '/') {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return cm.getCursor().line;\n          case '$':\n            return cm.lastLine();\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return markPos.line;\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          setOption(optionName, value, cm, setCfg);\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySlash(argString) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            regexPart = regexPart + '/' + flagsPart;\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); };\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n      var text = [];\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock ? vim.lastSelection.visualBlock.height : 1;\n        var changes = lastChange.changes;\n        var text = [];\n        var i = 0;\n        // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i]);\n          if (changes[i] instanceof InsertModeKey) {\n             i++;\n          } else {\n             i+= selLength;\n          }\n        }\n        lastChange.changes = text;\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      };\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(_cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            lastChange.changes.push(text);\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    };\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim;\n        var lastSel = vim.lastSelection;\n        var offset = getOffset(lastSel.anchor, lastSel.head);\n        selectForInsert(cm, head, offset.line + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          }\n        }\n      }\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n"]}