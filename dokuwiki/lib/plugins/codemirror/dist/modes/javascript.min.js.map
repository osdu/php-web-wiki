{"version":3,"sources":["../../node_modules/codemirror/mode/javascript/javascript.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","expressionAllowed","stream","state","backUp","test","lastType","string","slice","pos","defineMode","config","parserConfig","indentUnit","statementIndent","jsonldMode","jsonld","jsonMode","json","isTS","typescript","wordRE","wordCharacters","keywords","kw","type","style","A","B","C","operator","atom","jsKeywords","if","while","with","else","do","try","finally","return","break","continue","new","delete","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","typeof","instanceof","true","false","null","undefined","NaN","Infinity","this","class","super","yield","export","import","extends","await","async","tsKeywords","interface","implements","namespace","enum","public","private","protected","abstract","as","number","boolean","any","attr","isOperatorChar","isJsonldKeyword","readRegexp","escaped","next","inSet","content","ret","tp","cont","tokenBase","ch","tokenize","tokenString","match","eat","eatWhile","tokenComment","skipToEnd","current","tokenQuasi","lexical","word","known","propertyIsEnumerable","quote","peek","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","indexOf","start","m","exec","index","depth","sawSomething","charAt","bracket","atomicTypes","variable","regexp","jsonld-keyword","JSLexical","indented","column","align","prev","info","inScope","varname","v","localVars","name","cx","context","vars","parseJS","cc","marked","hasOwnProperty","combinator","length","pop","expression","statement","lex","pass","i","arguments","push","apply","register","inList","list","globalVars","defaultVars","pushcontext","popcontext","pushlex","result","indent","outer","poplex","expect","wanted","exp","value","vardef","parenExpr","block","maybeelse","functiondef","forspec","maybelabel","funarg","className","afterExport","afterImport","pattern","typeexpr","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","maybeexpressionNoComma","maybeexpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","expr","property","continueQuasi","targetNoComma","target","_","getterSetter","afterprop","what","end","sep","proceed","maybetype","afterType","typeprop","typearg","maybeReturnType","maybeAssign","vardefCont","proppattern","_type","forspec1","forspec2","formaybeinof","forspec3","classNameAfter","classBody","classfield","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","isContinuedStatement","textAfter","startState","basecolumn","token","sol","indentation","eatSpace","Pass","firstChar","top","c","closing","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","lineComment","fold","closeBrackets","helperType","skipExpression","registerHelper","defineMIME"],"mappings":"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","file":"javascript.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nfunction expressionAllowed(stream, state, backUp) {\n  return /^(?:operator|sof|keyword c|case|new|export|default|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n    (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n}\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": kw(\"new\"), \"delete\": C, \"throw\": C, \"debugger\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C, \"async\": kw(\"async\")\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"variable-3\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"class\"),\n        \"implements\": C,\n        \"namespace\": C,\n        \"module\": kw(\"module\"),\n        \"enum\": kw(\"module\"),\n        \"type\": kw(\"type\"),\n\n        // scope modifiers\n        \"public\": kw(\"modifier\"),\n        \"private\": kw(\"modifier\"),\n        \"protected\": kw(\"modifier\"),\n        \"abstract\": kw(\"modifier\"),\n\n        // operators\n        \"as\": operator,\n\n        // types\n        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/o/i)) {\n      stream.eatWhile(/[0-7]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/b/i)) {\n      stream.eatWhile(/[01]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\")\n        stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"module\") return cont(pushlex(\"form\"), pattern, pushlex(\"}\"), expect(\"{\"), block, poplex, poplex)\n    if (type == \"type\") return cont(typeexpr, expect(\"operator\"), typeexpr, expect(\";\"));\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), expression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\") return cont(pushlex(\"form\"), classExpression, poplex);\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"modifier\") {\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expression);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function typeexpr(type) {\n    if (type == \"variable\") {cx.marked = \"variable-3\"; return cont(afterType);}\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\", \",;\"), poplex)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType)\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    }\n  }\n  function typearg(type) {\n    if (type == \"variable\") return cont(typearg)\n    else if (type == \":\") return cont(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\") return cont(typeexpr)\n    if (type == \"[\") return cont(expect(\"]\"), afterType)\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"modifier\") return cont(pattern)\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, maybetype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, functiondef)\n  }\n  function funarg(type) {\n    if (type == \"spread\") return cont(funarg);\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\"))\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      if ((value == \"async\" || value == \"static\" || value == \"get\" || value == \"set\" ||\n           (isTS && (value == \"public\" || value == \"private\" || value == \"protected\" || value == \"readonly\" || value == \"abstract\"))) &&\n          cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false)) {\n        cx.marked = \"keyword\";\n        return cont(classBody);\n      }\n      cx.marked = \"property\";\n      return cont(isTS ? classfield : functiondef, classBody);\n    }\n    if (type == \"[\")\n      return cont(expression, expect(\"]\"), isTS ? classfield : functiondef, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    return pass(functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n"]}