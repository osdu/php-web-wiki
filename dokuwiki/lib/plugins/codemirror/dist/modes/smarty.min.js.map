{"version":3,"sources":["../../node_modules/codemirror/mode/smarty/smarty.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","parserConf","rightDelimiter","leftDelimiter","version","baseMode","getMode","keyFunctions","regs","operatorChars","validIdentifier","stringChar","last","cont","style","lastType","chain","stream","state","parser","tokenize","doesNotCount","pos","string","length","test","charAt","tokenTop","scan","nextMatch","indexOf","match","eat","tokenBlock","depth","tokenSmarty","slice","token","base","ch","next","eatWhile","tokenAttribute","str","c","i","j","quote","prevChar","currChar","eol","peek","terminator","startState","copyState","innerMode","mode","indent","text","Pass","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","file":"smarty.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Smarty 2 and 3 mode.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"smarty\", function(config, parserConf) {\n    var rightDelimiter = parserConf.rightDelimiter || \"}\";\n    var leftDelimiter = parserConf.leftDelimiter || \"{\";\n    var version = parserConf.version || 2;\n    var baseMode = CodeMirror.getMode(config, parserConf.baseMode || \"null\");\n\n    var keyFunctions = [\"debug\", \"extends\", \"function\", \"include\", \"literal\"];\n    var regs = {\n      operatorChars: /[+\\-*&%=<>!?]/,\n      validIdentifier: /[a-zA-Z0-9_]/,\n      stringChar: /['\"]/\n    };\n\n    var last;\n    function cont(style, lastType) {\n      last = lastType;\n      return style;\n    }\n\n    function chain(stream, state, parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode\n    function doesNotCount(stream, pos) {\n      if (pos == null) pos = stream.pos;\n      return version === 3 && leftDelimiter == \"{\" &&\n        (pos == stream.string.length || /\\s/.test(stream.string.charAt(pos)));\n    }\n\n    function tokenTop(stream, state) {\n      var string = stream.string;\n      for (var scan = stream.pos;;) {\n        var nextMatch = string.indexOf(leftDelimiter, scan);\n        scan = nextMatch + leftDelimiter.length;\n        if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;\n      }\n      if (nextMatch == stream.pos) {\n        stream.match(leftDelimiter);\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, tokenBlock(\"comment\", \"*\" + rightDelimiter));\n        } else {\n          state.depth++;\n          state.tokenize = tokenSmarty;\n          last = \"startTag\";\n          return \"tag\";\n        }\n      }\n\n      if (nextMatch > -1) stream.string = string.slice(0, nextMatch);\n      var token = baseMode.token(stream, state.base);\n      if (nextMatch > -1) stream.string = string;\n      return token;\n    }\n\n    // parsing Smarty content\n    function tokenSmarty(stream, state) {\n      if (stream.match(rightDelimiter, true)) {\n        if (version === 3) {\n          state.depth--;\n          if (state.depth <= 0) {\n            state.tokenize = tokenTop;\n          }\n        } else {\n          state.tokenize = tokenTop;\n        }\n        return cont(\"tag\", null);\n      }\n\n      if (stream.match(leftDelimiter, true)) {\n        state.depth++;\n        return cont(\"tag\", \"startTag\");\n      }\n\n      var ch = stream.next();\n      if (ch == \"$\") {\n        stream.eatWhile(regs.validIdentifier);\n        return cont(\"variable-2\", \"variable\");\n      } else if (ch == \"|\") {\n        return cont(\"operator\", \"pipe\");\n      } else if (ch == \".\") {\n        return cont(\"operator\", \"property\");\n      } else if (regs.stringChar.test(ch)) {\n        state.tokenize = tokenAttribute(ch);\n        return cont(\"string\", \"string\");\n      } else if (regs.operatorChars.test(ch)) {\n        stream.eatWhile(regs.operatorChars);\n        return cont(\"operator\", \"operator\");\n      } else if (ch == \"[\" || ch == \"]\") {\n        return cont(\"bracket\", \"bracket\");\n      } else if (ch == \"(\" || ch == \")\") {\n        return cont(\"bracket\", \"operator\");\n      } else if (/\\d/.test(ch)) {\n        stream.eatWhile(/\\d/);\n        return cont(\"number\", \"number\");\n      } else {\n\n        if (state.last == \"variable\") {\n          if (ch == \"@\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"property\", \"property\");\n          } else if (ch == \"|\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"qualifier\", \"modifier\");\n          }\n        } else if (state.last == \"pipe\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"qualifier\", \"modifier\");\n        } else if (state.last == \"whitespace\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"attribute\", \"modifier\");\n        } if (state.last == \"property\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"property\", null);\n        } else if (/\\s/.test(ch)) {\n          last = \"whitespace\";\n          return null;\n        }\n\n        var str = \"\";\n        if (ch != \"/\") {\n          str += ch;\n        }\n        var c = null;\n        while (c = stream.eat(regs.validIdentifier)) {\n          str += c;\n        }\n        for (var i=0, j=keyFunctions.length; i<j; i++) {\n          if (keyFunctions[i] == str) {\n            return cont(\"keyword\", \"keyword\");\n          }\n        }\n        if (/\\s/.test(ch)) {\n          return null;\n        }\n        return cont(\"tag\", \"tag\");\n      }\n    }\n\n    function tokenAttribute(quote) {\n      return function(stream, state) {\n        var prevChar = null;\n        var currChar = null;\n        while (!stream.eol()) {\n          currChar = stream.peek();\n          if (stream.next() == quote && prevChar !== '\\\\') {\n            state.tokenize = tokenSmarty;\n            break;\n          }\n          prevChar = currChar;\n        }\n        return \"string\";\n      };\n    }\n\n    function tokenBlock(style, terminator) {\n      return function(stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = tokenTop;\n            break;\n          }\n          stream.next();\n        }\n        return style;\n      };\n    }\n\n    return {\n      startState: function() {\n        return {\n          base: CodeMirror.startState(baseMode),\n          tokenize: tokenTop,\n          last: null,\n          depth: 0\n        };\n      },\n      copyState: function(state) {\n        return {\n          base: CodeMirror.copyState(baseMode, state.base),\n          tokenize: state.tokenize,\n          last: state.last,\n          depth: state.depth\n        };\n      },\n      innerMode: function(state) {\n        if (state.tokenize == tokenTop)\n          return {mode: baseMode, state: state.base};\n      },\n      token: function(stream, state) {\n        var style = state.tokenize(stream, state);\n        state.last = last;\n        return style;\n      },\n      indent: function(state, text) {\n        if (state.tokenize == tokenTop && baseMode.indent)\n          return baseMode.indent(state.base, text);\n        else\n          return CodeMirror.Pass;\n      },\n      blockCommentStart: leftDelimiter + \"*\",\n      blockCommentEnd: \"*\" + rightDelimiter\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-smarty\", \"smarty\");\n});\n"]}