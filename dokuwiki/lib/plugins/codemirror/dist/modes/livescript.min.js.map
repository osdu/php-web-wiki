{"version":3,"sources":["../../node_modules/codemirror/mode/livescript/livescript.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","tokenBase","stream","state","next_rule","next","nr","Rules","splice","i$","length","r","regex","match","token","external","startState","lastToken","style","indent","content","pos","start","indentation","current","replace","indenter","identifier","RegExp","keywordend","stringfill","heregex","key","comment","qdoc","qqdoc","qstring","qqstring","js","words","idx","i","len","rr","defineMIME"],"mappings":"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","file":"livescript.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/duralog/CodeMirror\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode('livescript', function(){\n    var tokenBase = function(stream, state) {\n      var next_rule = state.next || \"start\";\n      if (next_rule) {\n        state.next = state.next;\n        var nr = Rules[next_rule];\n        if (nr.splice) {\n          for (var i$ = 0; i$ < nr.length; ++i$) {\n            var r = nr[i$];\n            if (r.regex && stream.match(r.regex)) {\n              state.next = r.next || state.next;\n              return r.token;\n            }\n          }\n          stream.next();\n          return 'error';\n        }\n        if (stream.match(r = Rules[next_rule])) {\n          if (r.regex && stream.match(r.regex)) {\n            state.next = r.next;\n            return r.token;\n          } else {\n            stream.next();\n            return 'error';\n          }\n        }\n      }\n      stream.next();\n      return 'error';\n    };\n    var external = {\n      startState: function(){\n        return {\n          next: 'start',\n          lastToken: {style: null, indent: 0, content: \"\"}\n        };\n      },\n      token: function(stream, state){\n        while (stream.pos == stream.start)\n          var style = tokenBase(stream, state);\n        state.lastToken = {\n          style: style,\n          indent: stream.indentation(),\n          content: stream.current()\n        };\n        return style.replace(/\\./g, ' ');\n      },\n      indent: function(state){\n        var indentation = state.lastToken.indent;\n        if (state.lastToken.content.match(indenter)) {\n          indentation += 2;\n        }\n        return indentation;\n      }\n    };\n    return external;\n  });\n\n  var identifier = '(?![\\\\d\\\\s])[$\\\\w\\\\xAA-\\\\uFFDC](?:(?!\\\\s)[$\\\\w\\\\xAA-\\\\uFFDC]|-[A-Za-z])*';\n  var indenter = RegExp('(?:[({[=:]|[-~]>|\\\\b(?:e(?:lse|xport)|d(?:o|efault)|t(?:ry|hen)|finally|import(?:\\\\s*all)?|const|var|let|new|catch(?:\\\\s*' + identifier + ')?))\\\\s*$');\n  var keywordend = '(?![$\\\\w]|-[A-Za-z]|\\\\s*:(?![:=]))';\n  var stringfill = {\n    token: 'string',\n    regex: '.+'\n  };\n  var Rules = {\n    start: [\n      {\n        token: 'comment.doc',\n        regex: '/\\\\*',\n        next: 'comment'\n      }, {\n        token: 'comment',\n        regex: '#.*'\n      }, {\n        token: 'keyword',\n        regex: '(?:t(?:h(?:is|row|en)|ry|ypeof!?)|c(?:on(?:tinue|st)|a(?:se|tch)|lass)|i(?:n(?:stanceof)?|mp(?:ort(?:\\\\s+all)?|lements)|[fs])|d(?:e(?:fault|lete|bugger)|o)|f(?:or(?:\\\\s+own)?|inally|unction)|s(?:uper|witch)|e(?:lse|x(?:tends|port)|val)|a(?:nd|rguments)|n(?:ew|ot)|un(?:less|til)|w(?:hile|ith)|o[fr]|return|break|let|var|loop)' + keywordend\n      }, {\n        token: 'constant.language',\n        regex: '(?:true|false|yes|no|on|off|null|void|undefined)' + keywordend\n      }, {\n        token: 'invalid.illegal',\n        regex: '(?:p(?:ackage|r(?:ivate|otected)|ublic)|i(?:mplements|nterface)|enum|static|yield)' + keywordend\n      }, {\n        token: 'language.support.class',\n        regex: '(?:R(?:e(?:gExp|ferenceError)|angeError)|S(?:tring|yntaxError)|E(?:rror|valError)|Array|Boolean|Date|Function|Number|Object|TypeError|URIError)' + keywordend\n      }, {\n        token: 'language.support.function',\n        regex: '(?:is(?:NaN|Finite)|parse(?:Int|Float)|Math|JSON|(?:en|de)codeURI(?:Component)?)' + keywordend\n      }, {\n        token: 'variable.language',\n        regex: '(?:t(?:hat|il|o)|f(?:rom|allthrough)|it|by|e)' + keywordend\n      }, {\n        token: 'identifier',\n        regex: identifier + '\\\\s*:(?![:=])'\n      }, {\n        token: 'variable',\n        regex: identifier\n      }, {\n        token: 'keyword.operator',\n        regex: '(?:\\\\.{3}|\\\\s+\\\\?)'\n      }, {\n        token: 'keyword.variable',\n        regex: '(?:@+|::|\\\\.\\\\.)',\n        next: 'key'\n      }, {\n        token: 'keyword.operator',\n        regex: '\\\\.\\\\s*',\n        next: 'key'\n      }, {\n        token: 'string',\n        regex: '\\\\\\\\\\\\S[^\\\\s,;)}\\\\]]*'\n      }, {\n        token: 'string.doc',\n        regex: '\\'\\'\\'',\n        next: 'qdoc'\n      }, {\n        token: 'string.doc',\n        regex: '\"\"\"',\n        next: 'qqdoc'\n      }, {\n        token: 'string',\n        regex: '\\'',\n        next: 'qstring'\n      }, {\n        token: 'string',\n        regex: '\"',\n        next: 'qqstring'\n      }, {\n        token: 'string',\n        regex: '`',\n        next: 'js'\n      }, {\n        token: 'string',\n        regex: '<\\\\[',\n        next: 'words'\n      }, {\n        token: 'string.regex',\n        regex: '//',\n        next: 'heregex'\n      }, {\n        token: 'string.regex',\n        regex: '\\\\/(?:[^[\\\\/\\\\n\\\\\\\\]*(?:(?:\\\\\\\\.|\\\\[[^\\\\]\\\\n\\\\\\\\]*(?:\\\\\\\\.[^\\\\]\\\\n\\\\\\\\]*)*\\\\])[^[\\\\/\\\\n\\\\\\\\]*)*)\\\\/[gimy$]{0,4}',\n        next: 'key'\n      }, {\n        token: 'constant.numeric',\n        regex: '(?:0x[\\\\da-fA-F][\\\\da-fA-F_]*|(?:[2-9]|[12]\\\\d|3[0-6])r[\\\\da-zA-Z][\\\\da-zA-Z_]*|(?:\\\\d[\\\\d_]*(?:\\\\.\\\\d[\\\\d_]*)?|\\\\.\\\\d[\\\\d_]*)(?:e[+-]?\\\\d[\\\\d_]*)?[\\\\w$]*)'\n      }, {\n        token: 'lparen',\n        regex: '[({[]'\n      }, {\n        token: 'rparen',\n        regex: '[)}\\\\]]',\n        next: 'key'\n      }, {\n        token: 'keyword.operator',\n        regex: '\\\\S+'\n      }, {\n        token: 'text',\n        regex: '\\\\s+'\n      }\n    ],\n    heregex: [\n      {\n        token: 'string.regex',\n        regex: '.*?//[gimy$?]{0,4}',\n        next: 'start'\n      }, {\n        token: 'string.regex',\n        regex: '\\\\s*#{'\n      }, {\n        token: 'comment.regex',\n        regex: '\\\\s+(?:#.*)?'\n      }, {\n        token: 'string.regex',\n        regex: '\\\\S+'\n      }\n    ],\n    key: [\n      {\n        token: 'keyword.operator',\n        regex: '[.?@!]+'\n      }, {\n        token: 'identifier',\n        regex: identifier,\n        next: 'start'\n      }, {\n        token: 'text',\n        regex: '',\n        next: 'start'\n      }\n    ],\n    comment: [\n      {\n        token: 'comment.doc',\n        regex: '.*?\\\\*/',\n        next: 'start'\n      }, {\n        token: 'comment.doc',\n        regex: '.+'\n      }\n    ],\n    qdoc: [\n      {\n        token: 'string',\n        regex: \".*?'''\",\n        next: 'key'\n      }, stringfill\n    ],\n    qqdoc: [\n      {\n        token: 'string',\n        regex: '.*?\"\"\"',\n        next: 'key'\n      }, stringfill\n    ],\n    qstring: [\n      {\n        token: 'string',\n        regex: '[^\\\\\\\\\\']*(?:\\\\\\\\.[^\\\\\\\\\\']*)*\\'',\n        next: 'key'\n      }, stringfill\n    ],\n    qqstring: [\n      {\n        token: 'string',\n        regex: '[^\\\\\\\\\"]*(?:\\\\\\\\.[^\\\\\\\\\"]*)*\"',\n        next: 'key'\n      }, stringfill\n    ],\n    js: [\n      {\n        token: 'string',\n        regex: '[^\\\\\\\\`]*(?:\\\\\\\\.[^\\\\\\\\`]*)*`',\n        next: 'key'\n      }, stringfill\n    ],\n    words: [\n      {\n        token: 'string',\n        regex: '.*?\\\\]>',\n        next: 'key'\n      }, stringfill\n    ]\n  };\n  for (var idx in Rules) {\n    var r = Rules[idx];\n    if (r.splice) {\n      for (var i = 0, len = r.length; i < len; ++i) {\n        var rr = r[i];\n        if (typeof rr.regex === 'string') {\n          Rules[idx][i].regex = new RegExp('^' + rr.regex);\n        }\n      }\n    } else if (typeof rr.regex === 'string') {\n      Rules[idx].regex = new RegExp('^' + r.regex);\n    }\n  }\n\n  CodeMirror.defineMIME('text/x-livescript', 'livescript');\n\n});\n"]}