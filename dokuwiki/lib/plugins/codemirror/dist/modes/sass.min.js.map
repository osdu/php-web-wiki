{"version":3,"sources":["../../node_modules/codemirror/mode/sass/sass.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","cssMode","mimeModes","propertyKeywords","colorKeywords","valueKeywords","fontProperties","tokenRegexp","words","RegExp","join","keywords","keywordsRegexp","operators","opRegexp","pseudoElementsRegexp","word","isEndLine","stream","peek","match","urlTokens","state","ch","next","tokenizer","tokenBase","eatSpace","buildStringTokenizer","comment","indentation","multiLine","sol","skipTo","skipToEnd","quote","greedy","stringTokenizer","nextChar","peekChar","previousChar","string","charAt","pos","endingString","cursorHalf","buildInterpolationTokenizer","currentTokenizer","indent","indentCount","lastScopeOffset","scopes","offset","currentOffset","indentUnit","unshift","dedent","length","shift","eatWhile","current","toLowerCase","prop","prevProp","hasOwnProperty","tokenLexer","style","startOfToken","withCurrentIndent","newScopes","i","scope","push","startState","type","definedVars","definedMixins","token","lastToken","content","defineMIME"],"mappings":"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","file":"sass.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../css/css\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"sass\", function(config) {\n  var cssMode = CodeMirror.mimeModes[\"text/css\"];\n  var propertyKeywords = cssMode.propertyKeywords || {},\n      colorKeywords = cssMode.colorKeywords || {},\n      valueKeywords = cssMode.valueKeywords || {},\n      fontProperties = cssMode.fontProperties || {};\n\n  function tokenRegexp(words) {\n    return new RegExp(\"^\" + words.join(\"|\"));\n  }\n\n  var keywords = [\"true\", \"false\", \"null\", \"auto\"];\n  var keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\n\n  var operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\",\n                   \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\",\"\\\\{\",\"\\\\}\",\":\"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\n\n  var word;\n\n  function isEndLine(stream) {\n    return !stream.peek() || stream.match(/\\s+$/, false);\n  }\n\n  function urlTokens(stream, state) {\n    var ch = stream.peek();\n\n    if (ch === \")\") {\n      stream.next();\n      state.tokenizer = tokenBase;\n      return \"operator\";\n    } else if (ch === \"(\") {\n      stream.next();\n      stream.eatSpace();\n\n      return \"operator\";\n    } else if (ch === \"'\" || ch === '\"') {\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return \"string\";\n    } else {\n      state.tokenizer = buildStringTokenizer(\")\", false);\n      return \"string\";\n    }\n  }\n  function comment(indentation, multiLine) {\n    return function(stream, state) {\n      if (stream.sol() && stream.indentation() <= indentation) {\n        state.tokenizer = tokenBase;\n        return tokenBase(stream, state);\n      }\n\n      if (multiLine && stream.skipTo(\"*/\")) {\n        stream.next();\n        stream.next();\n        state.tokenizer = tokenBase;\n      } else {\n        stream.skipToEnd();\n      }\n\n      return \"comment\";\n    };\n  }\n\n  function buildStringTokenizer(quote, greedy) {\n    if (greedy == null) { greedy = true; }\n\n    function stringTokenizer(stream, state) {\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== \"\\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== \"\\\\\"));\n\n      if (endingString) {\n        if (nextChar !== quote && greedy) { stream.next(); }\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        state.tokenizer = tokenBase;\n        return \"string\";\n      } else if (nextChar === \"#\" && peekChar === \"{\") {\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return \"operator\";\n      } else {\n        return \"string\";\n      }\n    }\n\n    return stringTokenizer;\n  }\n\n  function buildInterpolationTokenizer(currentTokenizer) {\n    return function(stream, state) {\n      if (stream.peek() === \"}\") {\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return \"operator\";\n      } else {\n        return tokenBase(stream, state);\n      }\n    };\n  }\n\n  function indent(state) {\n    if (state.indentCount == 0) {\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  }\n\n  function dedent(state) {\n    if (state.scopes.length == 1) return;\n\n    state.scopes.shift();\n  }\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek();\n\n    // Comment\n    if (stream.match(\"/*\")) {\n      state.tokenizer = comment(stream.indentation(), true);\n      return state.tokenizer(stream, state);\n    }\n    if (stream.match(\"//\")) {\n      state.tokenizer = comment(stream.indentation(), false);\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match(\"#{\")) {\n      state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return \"operator\";\n    }\n\n    // Strings\n    if (ch === '\"' || ch === \"'\") {\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return \"string\";\n    }\n\n    if(!state.cursorHalf){// state.cursorHalf === 0\n    // first half i.e. before : for key-value pairs\n    // including selectors\n\n      if (ch === \"-\") {\n        if (stream.match(/^-\\w+-/)) {\n          return \"meta\";\n        }\n      }\n\n      if (ch === \".\") {\n        stream.next();\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"qualifier\";\n        } else if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if (ch === \"#\") {\n        stream.next();\n        // ID selectors\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"builtin\";\n        }\n        if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"variable-2\";\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/))\n        return \"number\";\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/))\n        return \"unit\";\n\n      if (stream.match(keywordsRegexp))\n        return \"keyword\";\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        return \"atom\";\n      }\n\n      if (ch === \"=\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^=[\\w-]+/)) {\n          indent(state);\n          return \"meta\";\n        }\n      }\n\n      if (ch === \"+\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^\\+[\\w-]+/)){\n          return \"variable-3\";\n        }\n      }\n\n      if(ch === \"@\"){\n        if(stream.match(/@extend/)){\n          if(!stream.match(/\\s*[\\w]/))\n            dedent(state);\n        }\n      }\n\n\n      // Indent Directives\n      if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n        indent(state);\n        return \"def\";\n      }\n\n      // Other Directives\n      if (ch === \"@\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"def\";\n      }\n\n      if (stream.eatWhile(/[\\w-]/)){\n        if(stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/,false)){\n          word = stream.current().toLowerCase();\n          var prop = state.prevProp + \"-\" + word;\n          if (propertyKeywords.hasOwnProperty(prop)) {\n            return \"property\";\n          } else if (propertyKeywords.hasOwnProperty(word)) {\n            state.prevProp = word;\n            return \"property\";\n          } else if (fontProperties.hasOwnProperty(word)) {\n            return \"property\";\n          }\n          return \"tag\";\n        }\n        else if(stream.match(/ *:/,false)){\n          indent(state);\n          state.cursorHalf = 1;\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        }\n        else if(stream.match(/ *,/,false)){\n          return \"tag\";\n        }\n        else{\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if(ch === \":\"){\n        if (stream.match(pseudoElementsRegexp)){ // could be a pseudo-element\n          return \"variable-3\";\n        }\n        stream.next();\n        state.cursorHalf=1;\n        return \"operator\";\n      }\n\n    } // cursorHalf===0 ends here\n    else{\n\n      if (ch === \"#\") {\n        stream.next();\n        // Hex numbers\n        if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"number\";\n        }\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"number\";\n      }\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"unit\";\n      }\n\n      if (stream.match(keywordsRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"keyword\";\n      }\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"atom\";\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"variable-2\";\n      }\n\n      // bang character for !important, !default, etc.\n      if (ch === \"!\") {\n        stream.next();\n        state.cursorHalf = 0;\n        return stream.match(/^[\\w]+/) ? \"keyword\": \"operator\";\n      }\n\n      if (stream.match(opRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"operator\";\n      }\n\n      // attributes\n      if (stream.eatWhile(/[\\w-]/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        word = stream.current().toLowerCase();\n        if (valueKeywords.hasOwnProperty(word)) {\n          return \"atom\";\n        } else if (colorKeywords.hasOwnProperty(word)) {\n          return \"keyword\";\n        } else if (propertyKeywords.hasOwnProperty(word)) {\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        } else {\n          return \"tag\";\n        }\n      }\n\n      //stream.eatSpace();\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n        return null;\n      }\n\n    } // else ends here\n\n    if (stream.match(opRegexp))\n      return \"operator\";\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  }\n\n  function tokenLexer(stream, state) {\n    if (stream.sol()) state.indentCount = 0;\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === \"@return\" || current === \"}\"){\n      dedent(state);\n    }\n\n    if (style !== null) {\n      var startOfToken = stream.pos - current.length;\n\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++) {\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent)\n          newScopes.push(scope);\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  }\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: \"sass\"}],\n        indentCount: 0,\n        cursorHalf: 0,  // cursor half tells us if cursor lies after (1)\n                        // or before (0) colon (well... more or less)\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-sass\", \"sass\");\n\n});\n"]}