{"version":3,"sources":["../../node_modules/codemirror/mode/haskell/haskell.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","_config","modeConfig","switchState","source","setState","f","smallRE","largeRE","digitRE","hexitRE","octitRE","idRE","symbolRE","specialRE","whiteCharRE","normal","eatWhile","ch","next","test","eat","t","ncomment","stringLiteral","match","skipToEnd","type","nest","currNest","eol","stringGap","wellKnownWords","wkw","setType","i","arguments","length","override","overrideKeywords","word","hasOwnProperty","startState","copyState","s","token","stream","state","w","current","blockCommentStart","blockCommentEnd","lineComment","defineMIME"],"mappings":"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","file":"haskell.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"haskell\", function(_config, modeConfig) {\n\n  function switchState(source, setState, f) {\n    setState(f);\n    return f(source, setState);\n  }\n\n  // These should all be Unicode extended, as per the Haskell 2010 report\n  var smallRE = /[a-z_]/;\n  var largeRE = /[A-Z]/;\n  var digitRE = /\\d/;\n  var hexitRE = /[0-9A-Fa-f]/;\n  var octitRE = /[0-7]/;\n  var idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\n  var symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\n  var specialRE = /[(),;[\\]`{}]/;\n  var whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\n  function normal(source, setState) {\n    if (source.eatWhile(whiteCharRE)) {\n      return null;\n    }\n\n    var ch = source.next();\n    if (specialRE.test(ch)) {\n      if (ch == '{' && source.eat('-')) {\n        var t = \"comment\";\n        if (source.eat('#')) {\n          t = \"meta\";\n        }\n        return switchState(source, setState, ncomment(t, 1));\n      }\n      return null;\n    }\n\n    if (ch == '\\'') {\n      if (source.eat('\\\\')) {\n        source.next();  // should handle other escapes here\n      }\n      else {\n        source.next();\n      }\n      if (source.eat('\\'')) {\n        return \"string\";\n      }\n      return \"string error\";\n    }\n\n    if (ch == '\"') {\n      return switchState(source, setState, stringLiteral);\n    }\n\n    if (largeRE.test(ch)) {\n      source.eatWhile(idRE);\n      if (source.eat('.')) {\n        return \"qualifier\";\n      }\n      return \"variable-2\";\n    }\n\n    if (smallRE.test(ch)) {\n      source.eatWhile(idRE);\n      return \"variable\";\n    }\n\n    if (digitRE.test(ch)) {\n      if (ch == '0') {\n        if (source.eat(/[xX]/)) {\n          source.eatWhile(hexitRE); // should require at least 1\n          return \"integer\";\n        }\n        if (source.eat(/[oO]/)) {\n          source.eatWhile(octitRE); // should require at least 1\n          return \"number\";\n        }\n      }\n      source.eatWhile(digitRE);\n      var t = \"number\";\n      if (source.match(/^\\.\\d+/)) {\n        t = \"number\";\n      }\n      if (source.eat(/[eE]/)) {\n        t = \"number\";\n        source.eat(/[-+]/);\n        source.eatWhile(digitRE); // should require at least 1\n      }\n      return t;\n    }\n\n    if (ch == \".\" && source.eat(\".\"))\n      return \"keyword\";\n\n    if (symbolRE.test(ch)) {\n      if (ch == '-' && source.eat(/-/)) {\n        source.eatWhile(/-/);\n        if (!source.eat(symbolRE)) {\n          source.skipToEnd();\n          return \"comment\";\n        }\n      }\n      var t = \"variable\";\n      if (ch == ':') {\n        t = \"variable-2\";\n      }\n      source.eatWhile(symbolRE);\n      return t;\n    }\n\n    return \"error\";\n  }\n\n  function ncomment(type, nest) {\n    if (nest == 0) {\n      return normal;\n    }\n    return function(source, setState) {\n      var currNest = nest;\n      while (!source.eol()) {\n        var ch = source.next();\n        if (ch == '{' && source.eat('-')) {\n          ++currNest;\n        }\n        else if (ch == '-' && source.eat('}')) {\n          --currNest;\n          if (currNest == 0) {\n            setState(normal);\n            return type;\n          }\n        }\n      }\n      setState(ncomment(type, currNest));\n      return type;\n    };\n  }\n\n  function stringLiteral(source, setState) {\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == '\"') {\n        setState(normal);\n        return \"string\";\n      }\n      if (ch == '\\\\') {\n        if (source.eol() || source.eat(whiteCharRE)) {\n          setState(stringGap);\n          return \"string\";\n        }\n        if (source.eat('&')) {\n        }\n        else {\n          source.next(); // should handle other escapes here\n        }\n      }\n    }\n    setState(normal);\n    return \"string error\";\n  }\n\n  function stringGap(source, setState) {\n    if (source.eat('\\\\')) {\n      return switchState(source, setState, stringLiteral);\n    }\n    source.next();\n    setState(normal);\n    return \"error\";\n  }\n\n\n  var wellKnownWords = (function() {\n    var wkw = {};\n    function setType(t) {\n      return function () {\n        for (var i = 0; i < arguments.length; i++)\n          wkw[arguments[i]] = t;\n      };\n    }\n\n    setType(\"keyword\")(\n      \"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\",\n      \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\",\n      \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n\n    setType(\"keyword\")(\n      \"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n\n    setType(\"builtin\")(\n      \"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<=\", \"=<<\",\n      \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\", \"**\");\n\n    setType(\"builtin\")(\n      \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\", \"Eq\",\n      \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\", \"GT\",\n      \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\",\n      \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\",\n      \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\",\n      \"String\", \"True\");\n\n    setType(\"builtin\")(\n      \"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\",\n      \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\",\n      \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\",\n      \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\",\n      \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\",\n      \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\",\n      \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\",\n      \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\",\n      \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\",\n      \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\",\n      \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\",\n      \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\",\n      \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\",\n      \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\",\n      \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\",\n      \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\",\n      \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\",\n      \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\",\n      \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\",\n      \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\",\n      \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\",\n      \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\",\n      \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\",\n      \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\",\n      \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\",\n      \"zip3\", \"zipWith\", \"zipWith3\");\n\n    var override = modeConfig.overrideKeywords;\n    if (override) for (var word in override) if (override.hasOwnProperty(word))\n      wkw[word] = override[word];\n\n    return wkw;\n  })();\n\n\n\n  return {\n    startState: function ()  { return { f: normal }; },\n    copyState:  function (s) { return { f: s.f }; },\n\n    token: function(stream, state) {\n      var t = state.f(stream, function(s) { state.f = s; });\n      var w = stream.current();\n      return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n    },\n\n    blockCommentStart: \"{-\",\n    blockCommentEnd: \"-}\",\n    lineComment: \"--\"\n  };\n\n});\n\nCodeMirror.defineMIME(\"text/x-haskell\", \"haskell\");\n\n});\n"]}