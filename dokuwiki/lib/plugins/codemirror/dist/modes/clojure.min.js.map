{"version":3,"sources":["../../node_modules/codemirror/mode/clojure/clojure.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","options","BUILTIN","COMMENT","STRING","CHARACTER","ATOM","NUMBER","BRACKET","KEYWORD","VAR","INDENT_WORD_SKIP","indentUnit","NORMAL_INDENT_UNIT","makeKeywords","str","obj","words","split","i","length","atoms","keywords","builtins","indentKeys","tests","digit","digit_or_colon","hex","sign","exponent","keyword_char","symbol","block_indent","stateStack","indent","type","prev","this","pushStack","state","indentStack","popStack","isNumber","ch","stream","eat","eatWhile","test","peek","next","eatCharacter","first","match","startState","indentation","mode","token","sol","eatSpace","returnType","escaped","skipToEnd","keyWord","indentTemp","column","letter","propertyIsEnumerable","eol","current","backUp","closeBrackets","pairs","lineComment","defineMIME"],"mappings":"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","file":"clojure.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Author: Hans Engel\n * Branched from CodeMirror's Scheme mode (by Koh Zi Han, based on implementation by Koh Zi Chun)\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"clojure\", function (options) {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\", CHARACTER = \"string-2\",\n        ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\", KEYWORD = \"keyword\", VAR = \"variable\";\n    var INDENT_WORD_SKIP = options.indentUnit || 2;\n    var NORMAL_INDENT_UNIT = options.indentUnit || 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var atoms = makeKeywords(\"true false nil\");\n\n    var keywords = makeKeywords(\n      \"defn defn- def def- defonce defmulti defmethod defmacro defstruct deftype defprotocol defrecord defproject deftest \" +\n      \"slice defalias defhinted defmacro- defn-memo defnk defnk defonce- defunbound defunbound- defvar defvar- let letfn \" +\n      \"do case cond condp for loop recur when when-not when-let when-first if if-let if-not . .. -> ->> doto and or dosync \" +\n      \"doseq dotimes dorun doall load import unimport ns in-ns refer try catch finally throw with-open with-local-vars \" +\n      \"binding gen-class gen-and-load-class gen-and-save-class handler-case handle\");\n\n    var builtins = makeKeywords(\n        \"* *' *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* \" +\n        \"*compile-path* *compiler-options* *data-readers* *e *err* *file* *flush-on-newline* *fn-loader* *in* \" +\n        \"*math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* \" +\n        \"*source-path* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* + +' - -' -> \" +\n        \"->> ->ArrayChunk ->Vec ->VecNode ->VecSeq -cache-protocol-fn -reset-methods .. / < <= = == > >= EMPTY-NODE accessor \" +\n        \"aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! \" +\n        \"alter-var-root amap ancestors and apply areduce array-map aset aset-boolean aset-byte aset-char aset-double \" +\n        \"aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 \" +\n        \"bases bean bigdec bigint biginteger binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set \" +\n        \"bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn bound-fn* bound? butlast \" +\n        \"byte byte-array bytes case cat cast char char-array char-escape-string char-name-string char? chars chunk chunk-append \" +\n        \"chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors \" +\n        \"clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement completing concat cond condp \" +\n        \"conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? \" +\n        \"declare dedupe default-data-readers definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol \" +\n        \"defrecord defstruct deftype delay delay? deliver denominator deref derive descendants destructure disj disj! dissoc \" +\n        \"dissoc! distinct distinct? doall dorun doseq dosync dotimes doto double double-array doubles drop drop-last \" +\n        \"drop-while eduction empty empty? ensure enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info \" +\n        \"extend extend-protocol extend-type extenders extends? false? ffirst file-seq filter filterv find find-keyword \" +\n        \"find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn fn? \" +\n        \"fnext fnil for force format frequencies future future-call future-cancel future-cancelled? future-done? future? \" +\n        \"gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by hash \" +\n        \"hash-combine hash-map hash-set identical? identity if-let if-not ifn? import in-ns inc inc' init-proxy instance? \" +\n        \"int int-array integer? interleave intern interpose into into-array ints io! isa? iterate iterator-seq juxt keep \" +\n        \"keep-indexed key keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list list* list? load load-file \" +\n        \"load-reader load-string loaded-libs locking long long-array longs loop macroexpand macroexpand-1 make-array \" +\n        \"make-hierarchy map map-indexed map? mapcat mapv max max-key memfn memoize merge merge-with meta method-sig methods \" +\n        \"min min-key mod munge name namespace namespace-munge neg? newline next nfirst nil? nnext not not-any? not-empty \" +\n        \"not-every? not= ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias \" +\n        \"ns-unmap nth nthnext nthrest num number? numerator object-array odd? or parents partial partition partition-all \" +\n        \"partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos? pr pr-str prefer-method prefers \" +\n        \"primitives-classnames print print-ctor print-dup print-method print-simple print-str printf println println-str \" +\n        \"prn prn-str promise proxy proxy-call-with-super proxy-mappings proxy-name proxy-super push-thread-bindings pvalues \" +\n        \"quot rand rand-int rand-nth random-sample range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern \" +\n        \"re-seq read read-line read-string realized? reduce reduce-kv reductions ref ref-history-count ref-max-history \" +\n        \"ref-min-history ref-set refer refer-clojure reify release-pending-sends rem remove remove-all-methods \" +\n        \"remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! resolve rest \" +\n        \"restart-agent resultset-seq reverse reversible? rseq rsubseq satisfies? second select-keys send send-off seq seq? \" +\n        \"seque sequence sequential? set set-error-handler! set-error-mode! set-validator! set? short short-array shorts \" +\n        \"shuffle shutdown-agents slurp some some-fn sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? \" +\n        \"special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! symbol \" +\n        \"symbol? sync take take-last take-nth take-while test the-ns thread-bound? time to-array to-array-2d trampoline transduce \" +\n        \"transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec \" +\n        \"unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int \" +\n        \"unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int \"+\n        \"unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive unquote \" +\n        \"unquote-splicing update update-in update-proxy use val vals var-get var-set var? vary-meta vec vector vector-of \" +\n        \"vector? volatile! volatile? vreset! vswap! when when-first when-let when-not while with-bindings with-bindings* with-in-str with-loading-context \" +\n        \"with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn xml-seq zero? zipmap \" +\n        \"*default-data-reader-fn* as-> cond-> cond->> reduced reduced? send-via set-agent-send-executor! \" +\n        \"set-agent-send-off-executor! some-> some->>\");\n\n    var indentKeys = makeKeywords(\n        // Built-ins\n        \"ns fn def defn defmethod bound-fn if if-not case condp when while when-not when-first do future comment doto \" +\n        \"locking proxy with-open with-precision reify deftype defrecord defprotocol extend extend-protocol extend-type \" +\n        \"try catch \" +\n\n        // Binding forms\n        \"let letfn binding loop for doseq dotimes when-let if-let \" +\n\n        // Data structures\n        \"defstruct struct-map assoc \" +\n\n        // clojure.test\n        \"testing deftest \" +\n\n        // contrib\n        \"handler-case handle dotrace deftrace\");\n\n    var tests = {\n        digit: /\\d/,\n        digit_or_colon: /[\\d:]/,\n        hex: /[0-9a-f]/i,\n        sign: /[+-]/,\n        exponent: /e/i,\n        keyword_char: /[^\\s\\(\\[\\;\\)\\]]/,\n        symbol: /[\\w*+!\\-\\._?:<>\\/\\xa1-\\uffff]/,\n        block_indent: /^(?:def|with)[^\\/]+$|\\/(?:def|with)/\n    };\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    function isNumber(ch, stream){\n        // hex\n        if ( ch === '0' && stream.eat(/x/i) ) {\n            stream.eatWhile(tests.hex);\n            return true;\n        }\n\n        // leading sign\n        if ( ( ch == '+' || ch == '-' ) && ( tests.digit.test(stream.peek()) ) ) {\n          stream.eat(tests.sign);\n          ch = stream.next();\n        }\n\n        if ( tests.digit.test(ch) ) {\n            stream.eat(ch);\n            stream.eatWhile(tests.digit);\n\n            if ( '.' == stream.peek() ) {\n                stream.eat('.');\n                stream.eatWhile(tests.digit);\n            } else if ('/' == stream.peek() ) {\n                stream.eat('/');\n                stream.eatWhile(tests.digit);\n            }\n\n            if ( stream.eat(tests.exponent) ) {\n                stream.eat(tests.sign);\n                stream.eatWhile(tests.digit);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // Eat character that starts after backslash \\\n    function eatCharacter(stream) {\n        var first = stream.next();\n        // Read special literals: backspace, newline, space, return.\n        // Just read all lowercase letters.\n        if (first && first.match(/[a-z]/) && stream.match(/[a-z]+/, true)) {\n            return;\n        }\n        // Read unicode character: \\u1000 \\uA0a1\n        if (first === \"u\") {\n            stream.match(/[0-9a-z]{4}/i, true);\n        }\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (state.mode != \"string\" && stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    var next, escaped = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"\\\"\" && !escaped) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        escaped = !escaped && next == \"\\\\\";\n                    }\n                    returnType = STRING; // continue on in string mode\n                    break;\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n                    } else if (ch == \"\\\\\") {\n                        eatCharacter(stream);\n                        returnType = CHARACTER;\n                    } else if (ch == \"'\" && !( tests.digit_or_colon.test(stream.peek()) )) {\n                        returnType = ATOM;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (isNumber(ch,stream)){\n                        returnType = NUMBER;\n                    } else if (ch == \"(\" || ch == \"[\" || ch == \"{\" ) {\n                        var keyWord = '', indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        if (ch == \"(\") while ((letter = stream.eat(tests.keyword_char)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && (indentKeys.propertyIsEnumerable(keyWord) ||\n                                                   tests.block_indent.test(keyWord))) { // indent-word\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation the user defined spaces after\n                                pushStack(state, indentTemp + NORMAL_INDENT_UNIT, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\" || ch == \"}\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : (ch == \"]\" ? \"[\" :\"{\"))) {\n                            popStack(state);\n                        }\n                    } else if ( ch == \":\" ) {\n                        stream.eatWhile(tests.symbol);\n                        return ATOM;\n                    } else {\n                        stream.eatWhile(tests.symbol);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = KEYWORD;\n                        } else if (builtins && builtins.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else if (atoms && atoms.propertyIsEnumerable(stream.current())) {\n                            returnType = ATOM;\n                        } else {\n                          returnType = VAR;\n                        }\n                    }\n            }\n\n            return returnType;\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-clojure\", \"clojure\");\nCodeMirror.defineMIME(\"text/x-clojurescript\", \"clojure\");\nCodeMirror.defineMIME(\"application/edn\", \"clojure\");\n\n});\n"]}