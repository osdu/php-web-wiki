{"version":3,"sources":["../../node_modules/codemirror/mode/velocity/velocity.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","parseWords","str","obj","words","split","i","length","keywords","functions","specials","isOperatorChar","chain","stream","state","f","tokenize","tokenBase","beforeParams","ch","next","inString","inParams","lastTokenWasBuiltin","tokenString","test","eatWhile","eat","tokenComment","match","tokenUnparsed","skipToEnd","propertyIsEnumerable","current","word","peek","toLowerCase","pos","string","charAt","quote","escaped","end","maybeEnd","startState","token","eatSpace","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME"],"mappings":"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","file":"velocity.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"velocity\", function() {\n    function parseWords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var keywords = parseWords(\"#end #else #break #stop #[[ #]] \" +\n                              \"#{end} #{else} #{break} #{stop}\");\n    var functions = parseWords(\"#if #elseif #foreach #set #include #parse #macro #define #evaluate \" +\n                               \"#{if} #{elseif} #{foreach} #{set} #{include} #{parse} #{macro} #{define} #{evaluate}\");\n    var specials = parseWords(\"$foreach.count $foreach.hasNext $foreach.first $foreach.last $foreach.topmost $foreach.parent.count $foreach.parent.hasNext $foreach.parent.first $foreach.parent.last $foreach.parent $velocityCount $!bodyContent $bodyContent\");\n    var isOperatorChar = /[+\\-*&%=<>!?:\\/|]/;\n\n    function chain(stream, state, f) {\n        state.tokenize = f;\n        return f(stream, state);\n    }\n    function tokenBase(stream, state) {\n        var beforeParams = state.beforeParams;\n        state.beforeParams = false;\n        var ch = stream.next();\n        // start of unparsed string?\n        if ((ch == \"'\") && !state.inString && state.inParams) {\n            state.lastTokenWasBuiltin = false;\n            return chain(stream, state, tokenString(ch));\n        }\n        // start of parsed string?\n        else if ((ch == '\"')) {\n            state.lastTokenWasBuiltin = false;\n            if (state.inString) {\n                state.inString = false;\n                return \"string\";\n            }\n            else if (state.inParams)\n                return chain(stream, state, tokenString(ch));\n        }\n        // is it one of the special signs []{}().,;? Seperator?\n        else if (/[\\[\\]{}\\(\\),;\\.]/.test(ch)) {\n            if (ch == \"(\" && beforeParams)\n                state.inParams = true;\n            else if (ch == \")\") {\n                state.inParams = false;\n                state.lastTokenWasBuiltin = true;\n            }\n            return null;\n        }\n        // start of a number value?\n        else if (/\\d/.test(ch)) {\n            state.lastTokenWasBuiltin = false;\n            stream.eatWhile(/[\\w\\.]/);\n            return \"number\";\n        }\n        // multi line comment?\n        else if (ch == \"#\" && stream.eat(\"*\")) {\n            state.lastTokenWasBuiltin = false;\n            return chain(stream, state, tokenComment);\n        }\n        // unparsed content?\n        else if (ch == \"#\" && stream.match(/ *\\[ *\\[/)) {\n            state.lastTokenWasBuiltin = false;\n            return chain(stream, state, tokenUnparsed);\n        }\n        // single line comment?\n        else if (ch == \"#\" && stream.eat(\"#\")) {\n            state.lastTokenWasBuiltin = false;\n            stream.skipToEnd();\n            return \"comment\";\n        }\n        // variable?\n        else if (ch == \"$\") {\n            stream.eatWhile(/[\\w\\d\\$_\\.{}]/);\n            // is it one of the specials?\n            if (specials && specials.propertyIsEnumerable(stream.current())) {\n                return \"keyword\";\n            }\n            else {\n                state.lastTokenWasBuiltin = true;\n                state.beforeParams = true;\n                return \"builtin\";\n            }\n        }\n        // is it a operator?\n        else if (isOperatorChar.test(ch)) {\n            state.lastTokenWasBuiltin = false;\n            stream.eatWhile(isOperatorChar);\n            return \"operator\";\n        }\n        else {\n            // get the whole word\n            stream.eatWhile(/[\\w\\$_{}@]/);\n            var word = stream.current();\n            // is it one of the listed keywords?\n            if (keywords && keywords.propertyIsEnumerable(word))\n                return \"keyword\";\n            // is it one of the listed functions?\n            if (functions && functions.propertyIsEnumerable(word) ||\n                    (stream.current().match(/^#@?[a-z0-9_]+ *$/i) && stream.peek()==\"(\") &&\n                     !(functions && functions.propertyIsEnumerable(word.toLowerCase()))) {\n                state.beforeParams = true;\n                state.lastTokenWasBuiltin = false;\n                return \"keyword\";\n            }\n            if (state.inString) {\n                state.lastTokenWasBuiltin = false;\n                return \"string\";\n            }\n            if (stream.pos > word.length && stream.string.charAt(stream.pos-word.length-1)==\".\" && state.lastTokenWasBuiltin)\n                return \"builtin\";\n            // default: just a \"word\"\n            state.lastTokenWasBuiltin = false;\n            return null;\n        }\n    }\n\n    function tokenString(quote) {\n        return function(stream, state) {\n            var escaped = false, next, end = false;\n            while ((next = stream.next()) != null) {\n                if ((next == quote) && !escaped) {\n                    end = true;\n                    break;\n                }\n                if (quote=='\"' && stream.peek() == '$' && !escaped) {\n                    state.inString = true;\n                    end = true;\n                    break;\n                }\n                escaped = !escaped && next == \"\\\\\";\n            }\n            if (end) state.tokenize = tokenBase;\n            return \"string\";\n        };\n    }\n\n    function tokenComment(stream, state) {\n        var maybeEnd = false, ch;\n        while (ch = stream.next()) {\n            if (ch == \"#\" && maybeEnd) {\n                state.tokenize = tokenBase;\n                break;\n            }\n            maybeEnd = (ch == \"*\");\n        }\n        return \"comment\";\n    }\n\n    function tokenUnparsed(stream, state) {\n        var maybeEnd = 0, ch;\n        while (ch = stream.next()) {\n            if (ch == \"#\" && maybeEnd == 2) {\n                state.tokenize = tokenBase;\n                break;\n            }\n            if (ch == \"]\")\n                maybeEnd++;\n            else if (ch != \" \")\n                maybeEnd = 0;\n        }\n        return \"meta\";\n    }\n    // Interface\n\n    return {\n        startState: function() {\n            return {\n                tokenize: tokenBase,\n                beforeParams: false,\n                inParams: false,\n                inString: false,\n                lastTokenWasBuiltin: false\n            };\n        },\n\n        token: function(stream, state) {\n            if (stream.eatSpace()) return null;\n            return state.tokenize(stream, state);\n        },\n        blockCommentStart: \"#*\",\n        blockCommentEnd: \"*#\",\n        lineComment: \"##\",\n        fold: \"velocity\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/velocity\", \"velocity\");\n\n});\n"]}