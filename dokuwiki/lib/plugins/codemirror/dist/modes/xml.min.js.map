{"version":3,"sources":["../../node_modules/codemirror/mode/xml/xml.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","htmlConfig","autoSelfClosers","area","base","br","col","command","embed","frame","hr","img","input","keygen","link","meta","param","source","track","wbr","menuitem","implicitlyClosed","dd","li","optgroup","option","p","rp","rt","tbody","td","tfoot","th","tr","contextGrabbers","dt","address","article","aside","blockquote","dir","div","dl","fieldset","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","menu","nav","ol","pre","section","table","ul","thead","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","defineMode","editorConf","config_","indentUnit","config","defaults","htmlMode","prop","type","setStyle","inText","stream","state","chain","parser","tokenize","ch","next","eat","match","inBlock","eatWhile","doctype","inTag","ok","isInText","baseState","tagName","tagStart","test","inAttribute","stringStartCol","column","quote","closure","eol","isInAttribute","style","terminator","depth","Context","startOfLine","this","prev","context","indent","indented","hasOwnProperty","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","current","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","startState","baseIndent","token","sol","indentation","eatSpace","textAfter","fullLine","Pass","length","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","exec","grabbers","electricInput","blockCommentStart","blockCommentEnd","configuration","helperType","skipAttribute","defineMIME","mimeModes","name"],"mappings":"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","file":"xml.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n"]}