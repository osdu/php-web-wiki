{"version":3,"sources":["../../node_modules/codemirror/mode/xquery/xquery.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","keywords","kw","type","style","A","B","C","operator","atom","punctuation","qualifier","kwObj","if","switch","while","for","else","then","try","finally","catch","element","attribute","let","implements","import","namespace","return","super","this","throws","where","private",",","null","fn:false()","fn:true()","basic","i","l","length","types","operators","axis_specifiers","chain","stream","state","f","tokenize","tokenBase","ch","next","mightBeFunction","isEQName","isEQNameAhead","match","tokenXMLComment","tokenCDATA","tokenPreProcessing","isclose","eat","eatSpace","tagName","c","tokenTag","pushStateStack","popStateStack","isInXmlBlock","test","tokenComment","tokenString","tokenVariable","known","propertyIsEnumerable","eatWhile","foundColon","word","current","isInXmlConstructor","maybeEnd","maybeNested","nestedCount","quote","isInString","name","isInXmlAttributeBlock","isVariableChar","tokenAttribute","isIn","stack","newState","push","pop","reinstateTokenize","startState","cc","token","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","file":"xquery.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"xquery\", function() {\n\n  // The keywords object is set to the result of this self executing\n  // function. Each keyword is a property of the keywords object whose\n  // value is {type: atype, style: astyle}\n  var keywords = function(){\n    // convenience functions used to build keywords object\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\")\n      , B = kw(\"keyword b\")\n      , C = kw(\"keyword c\")\n      , operator = kw(\"operator\")\n      , atom = {type: \"atom\", style: \"atom\"}\n      , punctuation = {type: \"punctuation\", style: null}\n      , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n    // kwObj is what is return from this function at the end\n    var kwObj = {\n      'if': A, 'switch': A, 'while': A, 'for': A,\n      'else': B, 'then': B, 'try': B, 'finally': B, 'catch': B,\n      'element': C, 'attribute': C, 'let': C, 'implements': C, 'import': C, 'module': C, 'namespace': C,\n      'return': C, 'super': C, 'this': C, 'throws': C, 'where': C, 'private': C,\n      ',': punctuation,\n      'null': atom, 'fn:false()': atom, 'fn:true()': atom\n    };\n\n    // a list of 'basic' keywords. For each add a property to kwObj with the value of\n    // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n    var basic = ['after','ancestor','ancestor-or-self','and','as','ascending','assert','attribute','before',\n    'by','case','cast','child','comment','declare','default','define','descendant','descendant-or-self',\n    'descending','document','document-node','element','else','eq','every','except','external','following',\n    'following-sibling','follows','for','function','if','import','in','instance','intersect','item',\n    'let','module','namespace','node','node','of','only','or','order','parent','precedes','preceding',\n    'preceding-sibling','processing-instruction','ref','return','returns','satisfies','schema','schema-element',\n    'self','some','sortby','stable','text','then','to','treat','typeswitch','union','variable','version','where',\n    'xquery', 'empty-sequence'];\n    for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n    // a list of types. For each add a property to kwObj with the value of\n    // {type: \"atom\", style: \"atom\"}\n    var types = ['xs:string', 'xs:float', 'xs:decimal', 'xs:double', 'xs:integer', 'xs:boolean', 'xs:date', 'xs:dateTime',\n    'xs:time', 'xs:duration', 'xs:dayTimeDuration', 'xs:time', 'xs:yearMonthDuration', 'numeric', 'xs:hexBinary',\n    'xs:base64Binary', 'xs:anyURI', 'xs:QName', 'xs:byte','xs:boolean','xs:anyURI','xf:yearMonthDuration'];\n    for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n    // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n    var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n    for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n    // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n    var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n    \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n    for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n    return kwObj;\n  }();\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  // the primary mode tokenizer\n  function tokenBase(stream, state) {\n    var ch = stream.next(),\n        mightBeFunction = false,\n        isEQName = isEQNameAhead(stream);\n\n    // an XML tag (if not in some sub, chained tokenizer)\n    if (ch == \"<\") {\n      if(stream.match(\"!--\", true))\n        return chain(stream, state, tokenXMLComment);\n\n      if(stream.match(\"![CDATA\", false)) {\n        state.tokenize = tokenCDATA;\n        return \"tag\";\n      }\n\n      if(stream.match(\"?\", false)) {\n        return chain(stream, state, tokenPreProcessing);\n      }\n\n      var isclose = stream.eat(\"/\");\n      stream.eatSpace();\n      var tagName = \"\", c;\n      while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n      return chain(stream, state, tokenTag(tagName, isclose));\n    }\n    // start code block\n    else if(ch == \"{\") {\n      pushStateStack(state,{ type: \"codeblock\"});\n      return null;\n    }\n    // end code block\n    else if(ch == \"}\") {\n      popStateStack(state);\n      return null;\n    }\n    // if we're in an XML block\n    else if(isInXmlBlock(state)) {\n      if(ch == \">\")\n        return \"tag\";\n      else if(ch == \"/\" && stream.eat(\">\")) {\n        popStateStack(state);\n        return \"tag\";\n      }\n      else\n        return \"variable\";\n    }\n    // if a number\n    else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n      return \"atom\";\n    }\n    // comment start\n    else if (ch === \"(\" && stream.eat(\":\")) {\n      pushStateStack(state, { type: \"comment\"});\n      return chain(stream, state, tokenComment);\n    }\n    // quoted string\n    else if (  !isEQName && (ch === '\"' || ch === \"'\"))\n      return chain(stream, state, tokenString(ch));\n    // variable\n    else if(ch === \"$\") {\n      return chain(stream, state, tokenVariable);\n    }\n    // assignment\n    else if(ch ===\":\" && stream.eat(\"=\")) {\n      return \"keyword\";\n    }\n    // open paren\n    else if(ch === \"(\") {\n      pushStateStack(state, { type: \"paren\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \")\") {\n      popStateStack(state);\n      return null;\n    }\n    // open paren\n    else if(ch === \"[\") {\n      pushStateStack(state, { type: \"bracket\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \"]\") {\n      popStateStack(state);\n      return null;\n    }\n    else {\n      var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n      // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n      if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n      if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n      // gobble up a word if the character is not known\n      if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n      // gobble a colon in the case that is a lib func type call fn:doc\n      var foundColon = stream.eat(\":\");\n\n      // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n      // which should get matched as a keyword\n      if(!stream.eat(\":\") && foundColon) {\n        stream.eatWhile(/[\\w\\$_-]/);\n      }\n      // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n      if(stream.match(/^[ \\t]*\\(/, false)) {\n        mightBeFunction = true;\n      }\n      // is the word a keyword?\n      var word = stream.current();\n      known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n      // if we think it's a function call but not yet known,\n      // set style to variable for now for lack of something better\n      if(mightBeFunction && !known) known = {type: \"function_call\", style: \"variable def\"};\n\n      // if the previous word was element, attribute, axis specifier, this word should be the name of that\n      if(isInXmlConstructor(state)) {\n        popStateStack(state);\n        return \"variable\";\n      }\n      // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n      // push the stack so we know to look for it on the next word\n      if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n      // if the word is known, return the details of that else just call this a generic 'word'\n      return known ? known.style : \"variable\";\n    }\n  }\n\n  // handle comments, including nested\n  function tokenComment(stream, state) {\n    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n    while (ch = stream.next()) {\n      if (ch == \")\" && maybeEnd) {\n        if(nestedCount > 0)\n          nestedCount--;\n        else {\n          popStateStack(state);\n          break;\n        }\n      }\n      else if(ch == \":\" && maybeNested) {\n        nestedCount++;\n      }\n      maybeEnd = (ch == \":\");\n      maybeNested = (ch == \"(\");\n    }\n\n    return \"comment\";\n  }\n\n  // tokenizer for string literals\n  // optionally pass a tokenizer function to set state.tokenize back to when finished\n  function tokenString(quote, f) {\n    return function(stream, state) {\n      var ch;\n\n      if(isInString(state) && stream.current() == quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        return \"string\";\n      }\n\n      pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n      // if we're in a string and in an XML block, allow an embedded code block\n      if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n\n\n      while (ch = stream.next()) {\n        if (ch ==  quote) {\n          popStateStack(state);\n          if(f) state.tokenize = f;\n          break;\n        }\n        else {\n          // if we're in a string and in an XML block, allow an embedded code block in an attribute\n          if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n            state.tokenize = tokenBase;\n            return \"string\";\n          }\n\n        }\n      }\n\n      return \"string\";\n    };\n  }\n\n  // tokenizer for variables\n  function tokenVariable(stream, state) {\n    var isVariableChar = /[\\w\\$_-]/;\n\n    // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n    if(stream.eat(\"\\\"\")) {\n      while(stream.next() !== '\\\"'){};\n      stream.eat(\":\");\n    } else {\n      stream.eatWhile(isVariableChar);\n      if(!stream.match(\":=\", false)) stream.eat(\":\");\n    }\n    stream.eatWhile(isVariableChar);\n    state.tokenize = tokenBase;\n    return \"variable\";\n  }\n\n  // tokenizer for XML tags\n  function tokenTag(name, isclose) {\n    return function(stream, state) {\n      stream.eatSpace();\n      if(isclose && stream.eat(\">\")) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n        return \"tag\";\n      }\n      // self closing tag without attributes?\n      if(!stream.eat(\"/\"))\n        pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n      if(!stream.eat(\">\")) {\n        state.tokenize = tokenAttribute;\n        return \"tag\";\n      }\n      else {\n        state.tokenize = tokenBase;\n      }\n      return \"tag\";\n    };\n  }\n\n  // tokenizer for XML attributes\n  function tokenAttribute(stream, state) {\n    var ch = stream.next();\n\n    if(ch == \"/\" && stream.eat(\">\")) {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      if(isInXmlBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \">\") {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \"=\")\n      return null;\n    // quoted string\n    if (ch == '\"' || ch == \"'\")\n      return chain(stream, state, tokenString(ch, tokenAttribute));\n\n    if(!isInXmlAttributeBlock(state))\n      pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n    stream.eat(/[a-zA-Z_:]/);\n    stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n    stream.eatSpace();\n\n    // the case where the attribute has not value and the tag was closed\n    if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n    }\n\n    return \"attribute\";\n  }\n\n  // handle comments, including nested\n  function tokenXMLComment(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"-\" && stream.match(\"->\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n\n  // handle CDATA\n  function tokenCDATA(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"]\" && stream.match(\"]\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n  // handle preprocessing instructions\n  function tokenPreProcessing(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"?\" && stream.match(\">\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment meta\";\n      }\n    }\n  }\n\n\n  // functions to test the current context of the state\n  function isInXmlBlock(state) { return isIn(state, \"tag\"); }\n  function isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\n  function isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\n  function isInString(state) { return isIn(state, \"string\"); }\n\n  function isEQNameAhead(stream) {\n    // assume we've already eaten a quote (\")\n    if(stream.current() === '\"')\n      return stream.match(/^[^\\\"]+\\\"\\:/, false);\n    else if(stream.current() === '\\'')\n      return stream.match(/^[^\\\"]+\\'\\:/, false);\n    else\n      return false;\n  }\n\n  function isIn(state, type) {\n    return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n  }\n\n  function pushStateStack(state, newState) {\n    state.stack.push(newState);\n  }\n\n  function popStateStack(state) {\n    state.stack.pop();\n    var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n    state.tokenize = reinstateTokenize || tokenBase;\n  }\n\n  // the interface for the mode API\n  return {\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        cc: [],\n        stack: []\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      return style;\n    },\n\n    blockCommentStart: \"(:\",\n    blockCommentEnd: \":)\"\n\n  };\n\n});\n\nCodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n\n});\n"]}