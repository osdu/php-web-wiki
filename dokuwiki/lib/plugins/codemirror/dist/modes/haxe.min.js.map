{"version":3,"sources":["../../node_modules/codemirror/mode/haxe/haxe.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","parserConfig","indentUnit","kw","type","style","A","B","C","operator","atom","attribute","keywords","if","while","else","do","try","return","break","continue","new","throw","var","inline","static","using","public","private","cast","import","macro","function","catch","untyped","callback","for","switch","case","default","in","never","trace","class","abstract","enum","interface","typedef","extends","implements","dynamic","true","false","null","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","escaped","next","content","ret","tp","cont","haxeTokenBase","ch","haxeTokenString","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","quote","maybeEnd","atomicTypes","number","variable","string","regexp","HaxeLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","parseHaxe","cc","cx","marked","lexical","hasOwnProperty","combinator","length","pop","statement","lex","imported","typename","charAt","len","importedtypes","i","registerimport","importname","t","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","poplex","expect","wanted","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","startState","basecolumn","defaulttypes","token","sol","indentation","eatSpace","indent","textAfter","firstChar","closing","electricChars","blockCommentStart","blockCommentEnd","lineComment","defineMIME","inString","peek","skipTo"],"mappings":"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","file":"haxe.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"haxe\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n\n  // Tokenizer\n\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n  var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\n  var type = kw(\"typedef\");\n  var keywords = {\n    \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n    \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n    \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n    \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n    \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n    \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n    \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n    \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n    \"true\": atom, \"false\": atom, \"null\": atom\n  };\n\n  var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  function toUnescaped(stream, end) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (next == end && !escaped)\n        return true;\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n\n  function haxeTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      return chain(stream, state, haxeTokenString(ch));\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n      stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n      toUnescaped(stream, \"/\");\n      stream.eatWhile(/[gimsu]/);\n      return ret(\"regexp\", \"string-2\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        return chain(stream, state, haxeTokenComment);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      }\n    } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n    } else if (ch == \"@\") {\n      stream.eat(/:/);\n      stream.eatWhile(/[\\w_]/);\n      return ret (\"metadata\", \"meta\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    } else {\n      var word;\n      if(/[A-Z]/.test(ch)) {\n        stream.eatWhile(/[\\w_<>]/);\n        word = stream.current();\n        return ret(\"type\", \"variable-3\", word);\n      } else {\n        stream.eatWhile(/[\\w_]/);\n        var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n        return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n                       ret(\"variable\", \"variable\", word);\n      }\n    }\n  }\n\n  function haxeTokenString(quote) {\n    return function(stream, state) {\n      if (toUnescaped(stream, quote))\n        state.tokenize = haxeTokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function haxeTokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = haxeTokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\n  function HaxeLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n  }\n\n  function parseHaxe(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n        return style;\n      }\n    }\n  }\n\n  function imported(state, typename) {\n    if (/[a-z]/.test(typename.charAt(0)))\n      return false;\n    var len = state.importedtypes.length;\n    for (var i = 0; i<len; i++)\n      if(state.importedtypes[i]==typename) return true;\n  }\n\n  function registerimport(importname) {\n    var state = cx.state;\n    for (var t = state.importedtypes; t; t = t.next)\n      if(t.name == importname) return;\n    state.importedtypes = { name: importname, next: state.importedtypes };\n  }\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next)\n      if (v.name == name) return true;\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(varname, state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else if (state.globalVars) {\n      if (inList(varname, state.globalVars)) return;\n      state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: null};\n  function pushcontext() {\n    if (!cx.state.context) cx.state.localVars = defaultVars;\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  popcontext.lex = true;\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state;\n      state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function f(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(f);\n    }\n    return f;\n  }\n\n  function statement(type) {\n    if (type == \"@\") return cont(metadef);\n    if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                   poplex, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"import\") return cont(importdef, expect(\";\"));\n    if (type == \"typedef\") return cont(typedef);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n    if (type == \"type\" ) return cont(maybeoperator);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n    if (type == \"operator\") return cont(expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperator(type, value) {\n    if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n    if (type == \"operator\" || type == \":\") return cont(expression);\n    if (type == \";\") return;\n    if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n    if (type == \".\") return cont(property, maybeoperator);\n    if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n  }\n\n  function maybeattribute(type) {\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"var\") return cont(vardef1);\n  }\n\n  function metadef(type) {\n    if(type == \":\") return cont(metadef);\n    if(type == \"variable\") return cont(metadef);\n    if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n  }\n  function metaargs(type) {\n    if(type == \"variable\") return cont();\n  }\n\n  function importdef (type, value) {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n  }\n\n  function typedef (type, value)\n  {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n  }\n\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperator, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type) {\n    if (type == \"variable\") cx.marked = \"property\";\n    if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") return cont(what, proceed);\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      else return pass(what, proceed);\n    };\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function vardef1(type, value) {\n    if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n    return cont();\n  }\n  function vardef2(type, value) {\n    if (value == \"=\") return cont(expression, vardef2);\n    if (type == \",\") return cont(vardef1);\n  }\n  function forspec1(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return cont(forin, expression)\n    } else {\n      return pass()\n    }\n  }\n  function forin(_type, value) {\n    if (value == \"in\") return cont();\n  }\n  function functiondef(type, value) {\n    //function names starting with upper-case letters are recognised as types, so cludging them together here.\n    if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n    if (value == \"new\") return cont(functiondef);\n    if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n  }\n  function typeuse(type) {\n    if(type == \":\") return cont(typestring);\n  }\n  function typestring(type) {\n    if(type == \"type\") return cont();\n    if(type == \"variable\") return cont();\n    if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n  }\n  function typeprop(type) {\n    if(type == \"variable\") return cont(typeuse);\n  }\n  function funarg(type, value) {\n    if (type == \"variable\") {register(value); return cont(typeuse);}\n  }\n\n  // Interface\n  return {\n    startState: function(basecolumn) {\n      var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n      var state = {\n        tokenize: haxeTokenBase,\n        reAllowed: true,\n        kwAllowed: true,\n        cc: [],\n        lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        importedtypes: defaulttypes,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n      state.kwAllowed = type != '.';\n      return parseHaxe(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != haxeTokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + 4;\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;\n      else if (lexical.info == \"switch\" && !closing)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \"{}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n\nCodeMirror.defineMode(\"hxml\", function () {\n\n  return {\n    startState: function () {\n      return {\n        define: false,\n        inString: false\n      };\n    },\n    token: function (stream, state) {\n      var ch = stream.peek();\n      var sol = stream.sol();\n\n      ///* comments */\n      if (ch == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      if (sol && ch == \"-\") {\n        var style = \"variable-2\";\n\n        stream.eat(/-/);\n\n        if (stream.peek() == \"-\") {\n          stream.eat(/-/);\n          style = \"keyword a\";\n        }\n\n        if (stream.peek() == \"D\") {\n          stream.eat(/[D]/);\n          style = \"keyword c\";\n          state.define = true;\n        }\n\n        stream.eatWhile(/[A-Z]/i);\n        return style;\n      }\n\n      var ch = stream.peek();\n\n      if (state.inString == false && ch == \"'\") {\n        state.inString = true;\n        ch = stream.next();\n      }\n\n      if (state.inString == true) {\n        if (stream.skipTo(\"'\")) {\n\n        } else {\n          stream.skipToEnd();\n        }\n\n        if (stream.peek() == \"'\") {\n          stream.next();\n          state.inString = false;\n        }\n\n        return \"string\";\n      }\n\n      stream.next();\n      return null;\n    },\n    lineComment: \"#\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n\n});\n"]}