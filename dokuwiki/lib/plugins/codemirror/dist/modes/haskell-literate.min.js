(function(a){if(typeof exports=="object"&&typeof module=="object")a(require("../../lib/codemirror"),require("../haskell/haskell"));else if(typeof define=="function"&&define.amd)define(["../../lib/codemirror","../haskell/haskell"],a);else a(CodeMirror)})(function(a){"use strict";a.defineMode("haskell-literate",function(b,c){var d=a.getMode(b,c&&c.base||"haskell");return{startState:function(){return{inCode:false,baseState:a.startState(d)}},token:function(a,b){if(a.sol()){if(b.inCode=a.eat(">"))return"meta"}if(b.inCode){return d.token(a,b.baseState)}else{a.skipToEnd();return"comment"}},innerMode:function(a){return a.inCode?{state:a.baseState,mode:d}:null}}},"haskell");a.defineMIME("text/x-literate-haskell","haskell-literate")});
//# sourceMappingURL=haskell-literate.min.js.map