{"version":3,"sources":["../../node_modules/codemirror/mode/elm/elm.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","switchState","source","setState","f","smallRE","largeRE","digitRE","hexitRE","octitRE","idRE","symbolRE","specialRE","whiteCharRE","normal","eatWhile","ch","next","test","eat","t","ncomment","stringLiteral","isDef","pos","skipToEnd","type","nest","currNest","eol","stringGap","wellKnownWords","wkw","keywords","i","length","startState","copyState","s","token","stream","state","w","current","hasOwnProperty","defineMIME"],"mappings":"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","file":"elm.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"elm\", function() {\n\n    function switchState(source, setState, f) {\n      setState(f);\n      return f(source, setState);\n    }\n\n    // These should all be Unicode extended, as per the Haskell 2010 report\n    var smallRE = /[a-z_]/;\n    var largeRE = /[A-Z]/;\n    var digitRE = /[0-9]/;\n    var hexitRE = /[0-9A-Fa-f]/;\n    var octitRE = /[0-7]/;\n    var idRE = /[a-z_A-Z0-9\\']/;\n    var symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:\\u03BB\\u2192]/;\n    var specialRE = /[(),;[\\]`{}]/;\n    var whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\n    function normal() {\n      return function (source, setState) {\n        if (source.eatWhile(whiteCharRE)) {\n          return null;\n        }\n\n        var ch = source.next();\n        if (specialRE.test(ch)) {\n          if (ch == '{' && source.eat('-')) {\n            var t = \"comment\";\n            if (source.eat('#')) t = \"meta\";\n            return switchState(source, setState, ncomment(t, 1));\n          }\n          return null;\n        }\n\n        if (ch == '\\'') {\n          if (source.eat('\\\\'))\n            source.next();  // should handle other escapes here\n          else\n            source.next();\n\n          if (source.eat('\\''))\n            return \"string\";\n          return \"error\";\n        }\n\n        if (ch == '\"') {\n          return switchState(source, setState, stringLiteral);\n        }\n\n        if (largeRE.test(ch)) {\n          source.eatWhile(idRE);\n          if (source.eat('.'))\n            return \"qualifier\";\n          return \"variable-2\";\n        }\n\n        if (smallRE.test(ch)) {\n          var isDef = source.pos === 1;\n          source.eatWhile(idRE);\n          return isDef ? \"variable-3\" : \"variable\";\n        }\n\n        if (digitRE.test(ch)) {\n          if (ch == '0') {\n            if (source.eat(/[xX]/)) {\n              source.eatWhile(hexitRE); // should require at least 1\n              return \"integer\";\n            }\n            if (source.eat(/[oO]/)) {\n              source.eatWhile(octitRE); // should require at least 1\n              return \"number\";\n            }\n          }\n          source.eatWhile(digitRE);\n          var t = \"number\";\n          if (source.eat('.')) {\n            t = \"number\";\n            source.eatWhile(digitRE); // should require at least 1\n          }\n          if (source.eat(/[eE]/)) {\n            t = \"number\";\n            source.eat(/[-+]/);\n            source.eatWhile(digitRE); // should require at least 1\n          }\n          return t;\n        }\n\n        if (symbolRE.test(ch)) {\n          if (ch == '-' && source.eat(/-/)) {\n            source.eatWhile(/-/);\n            if (!source.eat(symbolRE)) {\n              source.skipToEnd();\n              return \"comment\";\n            }\n          }\n          source.eatWhile(symbolRE);\n          return \"builtin\";\n        }\n\n        return \"error\";\n      }\n    }\n\n    function ncomment(type, nest) {\n      if (nest == 0) {\n        return normal();\n      }\n      return function(source, setState) {\n        var currNest = nest;\n        while (!source.eol()) {\n          var ch = source.next();\n          if (ch == '{' && source.eat('-')) {\n            ++currNest;\n          } else if (ch == '-' && source.eat('}')) {\n            --currNest;\n            if (currNest == 0) {\n              setState(normal());\n              return type;\n            }\n          }\n        }\n        setState(ncomment(type, currNest));\n        return type;\n      }\n    }\n\n    function stringLiteral(source, setState) {\n      while (!source.eol()) {\n        var ch = source.next();\n        if (ch == '\"') {\n          setState(normal());\n          return \"string\";\n        }\n        if (ch == '\\\\') {\n          if (source.eol() || source.eat(whiteCharRE)) {\n            setState(stringGap);\n            return \"string\";\n          }\n          if (!source.eat('&')) source.next(); // should handle other escapes here\n        }\n      }\n      setState(normal());\n      return \"error\";\n    }\n\n    function stringGap(source, setState) {\n      if (source.eat('\\\\')) {\n        return switchState(source, setState, stringLiteral);\n      }\n      source.next();\n      setState(normal());\n      return \"error\";\n    }\n\n\n    var wellKnownWords = (function() {\n      var wkw = {};\n\n      var keywords = [\n        \"case\", \"of\", \"as\",\n        \"if\", \"then\", \"else\",\n        \"let\", \"in\",\n        \"infix\", \"infixl\", \"infixr\",\n        \"type\", \"alias\",\n        \"input\", \"output\", \"foreign\", \"loopback\",\n        \"module\", \"where\", \"import\", \"exposing\",\n        \"_\", \"..\", \"|\", \":\", \"=\", \"\\\\\", \"\\\"\", \"->\", \"<-\"\n      ];\n\n      for (var i = keywords.length; i--;)\n        wkw[keywords[i]] = \"keyword\";\n\n      return wkw;\n    })();\n\n\n\n    return {\n      startState: function ()  { return { f: normal() }; },\n      copyState:  function (s) { return { f: s.f }; },\n\n      token: function(stream, state) {\n        var t = state.f(stream, function(s) { state.f = s; });\n        var w = stream.current();\n        return (wellKnownWords.hasOwnProperty(w)) ? wellKnownWords[w] : t;\n      }\n    };\n\n  });\n\n  CodeMirror.defineMIME(\"text/x-elm\", \"elm\");\n});\n"]}