{"version":3,"sources":["../../node_modules/codemirror/mode/ebnf/ebnf.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","commentType","slash","parenthesis","stateType","comment","_string","characterClass","bracesMode","getMode","startState","stringType","braced","lhs","localState","stack","inDefinition","token","stream","state","length","peek","next","unshift","match","eol","shift","text","current","i","skipToEnd","indexOf","eatSpace","defineMIME"],"mappings":"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","file":"ebnf.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"ebnf\", function (config) {\n    var commentType = {slash: 0, parenthesis: 1};\n    var stateType = {comment: 0, _string: 1, characterClass: 2};\n    var bracesMode = null;\n\n    if (config.bracesMode)\n      bracesMode = CodeMirror.getMode(config, config.bracesMode);\n\n    return {\n      startState: function () {\n        return {\n          stringType: null,\n          commentType: null,\n          braced: 0,\n          lhs: true,\n          localState: null,\n          stack: [],\n          inDefinition: false\n        };\n      },\n      token: function (stream, state) {\n        if (!stream) return;\n\n        //check for state changes\n        if (state.stack.length === 0) {\n          //strings\n          if ((stream.peek() == '\"') || (stream.peek() == \"'\")) {\n            state.stringType = stream.peek();\n            stream.next(); // Skip quote\n            state.stack.unshift(stateType._string);\n          } else if (stream.match(/^\\/\\*/)) { //comments starting with /*\n            state.stack.unshift(stateType.comment);\n            state.commentType = commentType.slash;\n          } else if (stream.match(/^\\(\\*/)) { //comments starting with (*\n            state.stack.unshift(stateType.comment);\n            state.commentType = commentType.parenthesis;\n          }\n        }\n\n        //return state\n        //stack has\n        switch (state.stack[0]) {\n        case stateType._string:\n          while (state.stack[0] === stateType._string && !stream.eol()) {\n            if (stream.peek() === state.stringType) {\n              stream.next(); // Skip quote\n              state.stack.shift(); // Clear flag\n            } else if (stream.peek() === \"\\\\\") {\n              stream.next();\n              stream.next();\n            } else {\n              stream.match(/^.[^\\\\\\\"\\']*/);\n            }\n          }\n          return state.lhs ? \"property string\" : \"string\"; // Token style\n\n        case stateType.comment:\n          while (state.stack[0] === stateType.comment && !stream.eol()) {\n            if (state.commentType === commentType.slash && stream.match(/\\*\\//)) {\n              state.stack.shift(); // Clear flag\n              state.commentType = null;\n            } else if (state.commentType === commentType.parenthesis && stream.match(/\\*\\)/)) {\n              state.stack.shift(); // Clear flag\n              state.commentType = null;\n            } else {\n              stream.match(/^.[^\\*]*/);\n            }\n          }\n          return \"comment\";\n\n        case stateType.characterClass:\n          while (state.stack[0] === stateType.characterClass && !stream.eol()) {\n            if (!(stream.match(/^[^\\]\\\\]+/) || stream.match(/^\\\\./))) {\n              state.stack.shift();\n            }\n          }\n          return \"operator\";\n        }\n\n        var peek = stream.peek();\n\n        if (bracesMode !== null && (state.braced || peek === \"{\")) {\n          if (state.localState === null)\n            state.localState = CodeMirror.startState(bracesMode);\n\n          var token = bracesMode.token(stream, state.localState),\n          text = stream.current();\n\n          if (!token) {\n            for (var i = 0; i < text.length; i++) {\n              if (text[i] === \"{\") {\n                if (state.braced === 0) {\n                  token = \"matchingbracket\";\n                }\n                state.braced++;\n              } else if (text[i] === \"}\") {\n                state.braced--;\n                if (state.braced === 0) {\n                  token = \"matchingbracket\";\n                }\n              }\n            }\n          }\n          return token;\n        }\n\n        //no stack\n        switch (peek) {\n        case \"[\":\n          stream.next();\n          state.stack.unshift(stateType.characterClass);\n          return \"bracket\";\n        case \":\":\n        case \"|\":\n        case \";\":\n          stream.next();\n          return \"operator\";\n        case \"%\":\n          if (stream.match(\"%%\")) {\n            return \"header\";\n          } else if (stream.match(/[%][A-Za-z]+/)) {\n            return \"keyword\";\n          } else if (stream.match(/[%][}]/)) {\n            return \"matchingbracket\";\n          }\n          break;\n        case \"/\":\n          if (stream.match(/[\\/][A-Za-z]+/)) {\n          return \"keyword\";\n        }\n        case \"\\\\\":\n          if (stream.match(/[\\][a-z]+/)) {\n            return \"string-2\";\n          }\n        case \".\":\n          if (stream.match(\".\")) {\n            return \"atom\";\n          }\n        case \"*\":\n        case \"-\":\n        case \"+\":\n        case \"^\":\n          if (stream.match(peek)) {\n            return \"atom\";\n          }\n        case \"$\":\n          if (stream.match(\"$$\")) {\n            return \"builtin\";\n          } else if (stream.match(/[$][0-9]+/)) {\n            return \"variable-3\";\n          }\n        case \"<\":\n          if (stream.match(/<<[a-zA-Z_]+>>/)) {\n            return \"builtin\";\n          }\n        }\n\n        if (stream.match(/^\\/\\//)) {\n          stream.skipToEnd();\n          return \"comment\";\n        } else if (stream.match(/return/)) {\n          return \"operator\";\n        } else if (stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)) {\n          if (stream.match(/(?=[\\(.])/)) {\n            return \"variable\";\n          } else if (stream.match(/(?=[\\s\\n]*[:=])/)) {\n            return \"def\";\n          }\n          return \"variable-2\";\n        } else if ([\"[\", \"]\", \"(\", \")\"].indexOf(stream.peek()) != -1) {\n          stream.next();\n          return \"bracket\";\n        } else if (!stream.eatSpace()) {\n          stream.next();\n        }\n        return null;\n      }\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-ebnf\", \"ebnf\");\n});\n"]}